\documentclass[a4paper,12pt]{article}
\usepackage{amsmath}
\usepackage{pdfpages}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyhdr}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\pagestyle{fancy}
\fancyhf{}
\lhead{Contol theory Homework \#3 report}
\rhead{Anton Brisilin, BS18-02 Student, \\ 
a.brisilin@innopolis.university}
\fancyfoot[R]{\today}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}
\renewcommand{\headrulewidth}{1pt}

\begin{document}
\section{Task 1.}
My name is \textit{Anton Brisilin}, and my email is 
\textit{a.brisilin@innopolis.university}. 
My generated variant is \textbf{F}.
\section{Task 2.}
    \subsection*{Part A.}
        Design PD-controller that tracks time varying reference states, i.e.
        \\ $[x^*(t), \dot{x}^*(t)]$ as closely as possible. Test your controller on different
        trajectories, at least two. System: $x + \mu x + kx = u$, see variants below.\\
        For variant F, $\mu = 63, k = 15$
        Our open-loop system equation is 
        \begin{equation*}
            \ddot{x}+63\dot{x}+15x=u,
        \end{equation*}
        where $x=x(t)$, $u=u(t)$\\
        Our controller is required to be PD-controller. Hence, we have following formula
        for our input $u(t)$:
        \begin{equation*}
            u(t) = K_p e(t) + K_d\dot{e}(t)
        \end{equation*}
        As I will use \texttt{odeint()} function from \texttt{scipy.integrate} module,
        I will need a formula for a derivative vector of $\vec{x} = [x(t),\dot{x}(t)]^T$: 
        $\dot{\vec{x}} = [\dot{x}(t),\ddot{x}(t)]^T$. Hence I should convert my system to 
        state-space form.
        \begin{equation*}
            \begin{bmatrix}
                \dot{x}\\
                \ddot{x}
            \end{bmatrix}
            = 
            \begin{bmatrix}
                0 & 1 \\
                -15 & -63
            \end{bmatrix}
            \begin{bmatrix}
                x\\
                \dot{x}
            \end{bmatrix}
            +
            \begin{bmatrix}
                0 \\
                1
            \end{bmatrix}
            u
        \end{equation*}
        Adding our controller, we get 
        \begin{equation*}
            \begin{bmatrix}
                \dot{x}\\
                \ddot{x}
            \end{bmatrix}
            = 
            \begin{bmatrix}
                0 & 1 \\
                -15 & -63
            \end{bmatrix}
            \begin{bmatrix}
                x\\
                \dot{x}
            \end{bmatrix}
            +
            \begin{bmatrix}
                0 \\
                1
            \end{bmatrix}
            \begin{bmatrix}
                K_p & K_d
            \end{bmatrix}
            \left(
            \begin{bmatrix}
                x^*\\
                \dot{x^*}
            \end{bmatrix}
            -
            \begin{bmatrix}
                x\\
                \dot{x}
            \end{bmatrix}
            \right)
        \end{equation*}
        Now my goal is implement such a system in Python, you can find it in 
        \texttt{Task2/pd.py}. First of all, I declared $\mu$, k, right time 
        boudary and step for numerical solution as constants
        \lstinputlisting[language = Python, firstline=5, lastline=9]{../Task2/pd.py}
        Then I declared reference functions:
        \lstinputlisting[language = Python, firstline=18, lastline=22]{../Task2/pd.py}
        Then, I created a function that will compute our derivative vector (I think 
        this is most interesting part):
        \lstinputlisting[language = Python, firstline=30, lastline=34]{../Task2/pd.py}
        Using these functions, I can simulate work of the system, and try to tune the 
        coeffitients:
        \lstinputlisting[language = Python, firstline=38, lastline=51]{../Task2/pd.py}
        \subsubsection*{Testing on different trajectories}
            As a first reference trajectory I have chosen $x^*(t)=sin(10t) + t$, 
            $\dot{x}^*(t) = 10 cos(10t)+1$, with zero initial conditions. Here are the plots 
            of solution, obtained with $K_p = 100$, $K_d = 100$.
            \begin{center}
                \includegraphics[width = 0.8\linewidth]{2a_tr1.pdf}
            \end{center}
            As a second reference trajectory I have chosen $x^*(t)=sin(10t)$, 
            $\dot{x}^*(t) = 10 cos(10t)$, with zero initial conditions. Here are the plots 
            of solution, obtained with $K_p = 100$, $K_d = 100$.
            \begin{center}
                \includegraphics[width = 0.8\linewidth]{2a_tr2.pdf}
            \end{center}
            Third reference trajectory is just a step function $x^*(t)=1$, $\dot{x}^*(t) = 0$,
            with zero initial conditions. Here are the plots of solution, obtained with 
            $K_p = 5$, $K_d = 5$.
            \begin{center}
                \includegraphics[width = 0.8\linewidth]{2a_tr3.pdf}
            \end{center}
            As one can see, my controller poorly follows desired trajectory and need
            to be tuned for each trajectory individually. 
    \subsection*{Part B. Controller tuning}
        We begin with $K_p = 5$, $K_d = 5$. As you can see on the above plot, 
        it gives us a large steady - state error, so $K_p$ should be increased.\\ 
        I increased it, 
        until I got steady-state error $e \approx 10^{-2}$. The controller gains 
        are now $K_p = 2000$, $K_d = 5$
        \begin{center}
            \includegraphics[width = 0.72\linewidth]{2b_1.pdf}
        \end{center}
        Now we have almost no steady-state error, but there is an overshoot appeared
        now. Therefore, $K_d$ should be increased.\\
        I increased it, until I got rid of overshoot. The controller gains now are
        $K_p = 2000$, $K_d = 13$
        \begin{center}
            \includegraphics[width = 0.77\linewidth]{2b_2.pdf}
        \end{center}
        Now there is no overshoot, and steady-state error $e \approx 10^{-2}$, 
        as it can be seen from the plot. The gains are $K_p = 2000$, $K_d = 13$.
    \subsection*{Part C. Proving stability}
        For the controlled system 
        \begin{equation*}
            \begin{cases}
                \dot{x}=Ax+Bu\\
                u = -Kx
            \end{cases}
        \end{equation*}
        to be stable, all real parts of eigenvalues of matrix $[A-BK]$ should be
        negative. In our case, we have
        \begin{equation*}
            \begin{cases}
                \dot{x}=
                \begin{bmatrix}
                    0 & 1 \\
                    -15 & -63
                \end{bmatrix}
                x+
                \begin{bmatrix}
                    0 \\
                    1
                \end{bmatrix}
                u
                \\
                \\
                u = -
                \begin{bmatrix}
                    K_p & K_d
                \end{bmatrix}
                e
            \end{cases}
        \end{equation*}
        \begin{eqnarray*}
            A-BK = 
            \begin{bmatrix}
                0 & 1 \\
                -15 & -63
            \end{bmatrix}
            -
            \begin{bmatrix}
                0 \\
                1
            \end{bmatrix}
            \begin{bmatrix}
                2000 & 13
            \end{bmatrix}\\
            \\
            A-BK = 
            \begin{bmatrix}
                0 & 1 \\
                -15 & -63
            \end{bmatrix}
            -
            \begin{bmatrix}
                0 & 0\\
                2000 & 13
            \end{bmatrix}\\
            \\
            A-BK = 
            \begin{bmatrix}
                0 & 1 \\
                -2015 & -76
            \end{bmatrix}
        \end{eqnarray*}
        Using Matlab's \texttt{eig()} function, I obtained the eigenvalues, that 
        are
        \begin{equation*}
            eigenvalues = 
            \begin{bmatrix}
                -38 + 23.8956i\\
                -38 - 23.8956i
            \end{bmatrix}
        \end{equation*}
        As it can be seen, they have negative real parts, so the controlled system
        is stable.
    \subsection*{Part D.}
    Think of how you would implement PD control for a linear system:
    \begin{equation*}
        \begin{bmatrix}
            \dot{x_1}\\
            \dot{x_2}
        \end{bmatrix}
        = 
        \begin{bmatrix}
            10 & 3 \\
            5 & -5
        \end{bmatrix}
        \begin{bmatrix}
            x_1\\
            x_2
        \end{bmatrix}
    \end{equation*}
    This system is autonomous MIMO system. I need to add controller to it to 
    make it stable. First of all, let's check its stability by looking to its 
    eigenvalues, obtained with Python's \texttt{numply.linalg.eig()}.
    \begin{equation*}
        eigenvalues = 
        \begin{bmatrix}
            10.94\\
            -5.94
        \end{bmatrix}
    \end{equation*}
    As can be seen, it is unstable, because it has eigenvalue with positive
    real part. Thus, we need to add controller to the system. We do not want our 
    system to keep any trajectory, we just want to stabilize it. Therefore, we 
    want $\dot{x}$ go to zero in equation
    \begin{equation*}
        \dot{x} = Ax + BK_1e_1 + BK_2e_2,
    \end{equation*}
    where $K_1$ and $K_2$ are control matrices for input 1 and 2 respectively,
    $x$ is state vector, and $e_1$ and $e_2$ are errors. Below I assumed that 
    $K_1 = K_2$ and our equation takes the form
    \begin{equation*}
        \dot{x} = Ax + BK(e_1 + e_2),
    \end{equation*}
    Applying above equation to our case:
    \begin{equation*}
        \begin{bmatrix}
            \dot{x_1}\\
            \dot{x_2}
        \end{bmatrix}
        = 
        \begin{bmatrix}
            10 & 3 \\
            5 & -5
        \end{bmatrix}
        \begin{bmatrix}
            x_1\\
            x_2
        \end{bmatrix}
        +
        \begin{bmatrix}
            1 \\
            1
        \end{bmatrix}
        \begin{bmatrix}
            K_p & K_d
        \end{bmatrix}
        \left(
            \begin{bmatrix}
                e_1\\
                \dot{e_1}
            \end{bmatrix}
            +
            \begin{bmatrix}
                e_2\\
                \dot{e_2}
            \end{bmatrix}
        \right)
    \end{equation*}
    Now let me start implement it in Python. First, I declared some constants:
    \lstinputlisting[language = Python, firstline=6, lastline=17]{../Task2/pd1order.py}
    As we have no derivative in state vector, we should somehow calculate it. I 
    propose such formula for the derivative approximation:
    \begin{equation*}
        \dot x(t_i) = \frac{x(t_i) - x(t_{i-1})}{t_i - t_{i-1}}
    \end{equation*}
    As \texttt{odeint()} integrates numerically, it can try to compute differential
    with $t_i - t_{i-1}$ very small (or sometimes 0). That leads to numerical errors, and due to this
    I changed the formula to 
    \begin{equation*}
        \dot x(t_i) = \frac{x(t_i) - x(t_{i-1})}{max(t_i - t_{i-1}, 10^{-6})}
    \end{equation*}
        
    With this assumpption, I can now implement differential function:
    \lstinputlisting[language = Python, firstline=22, lastline=39]{../Task2/pd1order.py}
    Integrating the solution:
    \lstinputlisting[language = Python, firstline=41, lastline=46]{../Task2/pd1order.py}
    The obtained plot of solition is presented below:
    \begin{center}
        \includegraphics[width=\linewidth]{2d.pdf}
    \end{center}
    As it can be seen, the controller tries to change the system state to desired 
    one in just one timestep. That is not physically possible, and this is always
    the case, when use derivatives of same order as systems themselves, to control
    the systems.
    \subsection*{Part E.}
    Implement a PI/PID controller for the system: 
    $\ddot{x}+\mu \dot{x} +kx+ 9.8 = u$
    (variants are below) Test your controller on different trajectories, at 
    least two.\\
    For this task, I decided to treat the system as third order one, with $x_1 = 
    \int xdx$, $x_2 = x$, and $x_3 = \dot x$. Then, I built a state space model 
    for the system, assuming that that constant term $9.8$ can be treated as input.
    \begin{equation*}
        \begin{bmatrix}
            \dot{x_1}\\
            \dot{x_2}\\
            \dot{x_3}
        \end{bmatrix}
        =
        \begin{bmatrix}
            0 & 1 & 0\\
            0 & 0 & 1\\
            0 & -k & -\mu
        \end{bmatrix}
        \begin{bmatrix}
            x_1\\
            x_2\\
            x_3
        \end{bmatrix}
        + (-9.8 + u)
        \begin{bmatrix}
            0\\
            0\\
            1
        \end{bmatrix}
    \end{equation*}
    Adding our controller to control the input of the system:
    \begin{equation*}
        \begin{bmatrix}
            \dot{x_1}\\
            \dot{x_2}\\
            \dot{x_3}
        \end{bmatrix}
        =
        \begin{bmatrix}
            0 & 1 & 0\\
            0 & 0 & 1\\
            0 & -k & -\mu
        \end{bmatrix}
        \begin{bmatrix}
            x_1\\
            x_2\\
            x_3
        \end{bmatrix}
        - 9.8
        \begin{bmatrix}
            0\\
            0\\
            1
        \end{bmatrix}
        +
        \begin{bmatrix}
            0\\
            0\\
            1
        \end{bmatrix}
        \begin{bmatrix}
            K_i & K_p & K_d
        \end{bmatrix}
        \begin{bmatrix}
            e_{int}\\
            e\\
            \dot{e}
        \end{bmatrix}
    \end{equation*}
    Now let's implement the system on Python. First, I define reference functions:
    \lstinputlisting[language = Python, firstline=6, lastline=13]{../Task2/pid.py}
    These functions describe our desired trajectory. 
    In our case, $\mu = 63, k = 15$, so I defined them and some other contants:
    \lstinputlisting[language = Python, firstline=15, lastline=24]{../Task2/pid.py}
    Then I defined differential function:
    \lstinputlisting[language = Python, firstline=26, lastline=31]{../Task2/pid.py}
    As a first trajectory for testing I choose step function $x(t)=1, \dot x(t)=0$
    Here is a plot of its solution with $K_p = 100, K_i = 30, K_d = 20$
    \begin{center}
        \includegraphics[width=\linewidth]{PID100-30-20.pdf}
    \end{center}
    Second trajectory is $x(t)=sin(t), \dot x(t) = cos(t)$
    Here is a plot of its solution with $K_p = 100, K_i = 30, K_d = 20$
    \begin{center}
        \includegraphics[width=\linewidth]{2PID100-30-20.pdf}
    \end{center}
    C =
 
  150 (s+10) (s+1)
  ----------------
       (s+5) 
\section{Used software.}
\begin{itemize}
    \item Python 3.8.1
    \item Matlab R2018b 9.5.0
\end{itemize}
All software was run under Manjaro Linux with 5.4.18-rt kernel
\end{document}